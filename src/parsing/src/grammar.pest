/** Main grammar entry point **/
main_grammar = { 
    SOI ~ 
    (
        (edb_decl ~ idb_decl | edb_decl | idb_decl) ~
        rule_decl? 
    )+
    ~ EOI
} 

/** Relation declarations **/
// Input relation declarations section
edb_decl = { ".in" ~ edb_relation_decl+ }
// Output relation declarations section
idb_decl = { (".printsize" | ".out") ~ idb_relation_decl+ }

// Input relation declaration - can have an optional .input directive
edb_relation_decl = { ".decl" ~ relation_name ~ "(" ~ attributes_decl ~ ")" ~ in_decl? }

// Output relation declaration - can have an optional .output directive
idb_relation_decl = { ".decl" ~ relation_name ~ "(" ~ attributes_decl? ~ ")" ~ out_decl? }

// Comma-separated list of attribute declarations
attributes_decl = { attribute_decl ~ ("," ~ attribute_decl)* }
// Single attribute with name and data type, e.g., "src: number" 
attribute_decl = { attribute_name ~ ":" ~ data_type }

/** Input/Output directives **/
// Directive to specify the input file path for a relation
in_decl = { ".input" ~ file_path }
// Directive to specify the output file path for a relation
out_decl = { ".output" ~ file_path}

// Path to IO file, e.g., "_Method-Modifier.facts"
file_path = @{ file_name ~ ("." ~ ( "facts" | "csv" | "txt" )) }
file_name = @{ "_"? ~ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "_" | "-")* }

/** Rules section **/
// Optional ".rule" keyword followed by one or more rules
rule_decl = { (".rule")? ~ rule+ }
// Single rule with head, body predicates, and optional optimization directive
rule = { head ~ ":-" ~ predicates ~ "." ~ optimize? }
// Comma-separated list of predicates in the rule body
predicates = { predicate ~ ("," ~ predicate)* }
// Types of predicates allowed in rule bodies
predicate = { atom | neg_atom | compare_expr | BOOLEAN } 
// Optimization hint directives
optimize = { ".plan" | ".sip" | ".optimize" }

/** Atoms (relation references) **/
// Relation with arguments, e.g., "edge(x, y)"
atom = { 
    relation_name ~ 
    "(" ~ 
    (atom_arg ~ ("," ~ atom_arg)*)? ~ 
    ")" 
}
// Negated atom, e.g., "!edge(x, y)"
neg_atom = { "!" ~ atom }
// Arguments in atoms can be variables, constants, or placeholders
atom_arg = { variable | constant | placeholder }

/** at most aggregate per head atom, e.g. R(x, min(z)) :- R(x, y), R(z, y), x > z. **/
// Allows:
// - one or more arithmics
// - one or more arithmics ending in a single aggregate
// - a single aggregate
head = {
    relation_name ~ (
         (   "(" ~ arithmics ~ "," ~ (arithmics ~ ",")* ~ arithmics ~ ")"   )
        |(   "(" ~ arithmics ~ "," ~ (arithmics ~ ",")* ~ aggregate ~ ")"   )
        |(   "(" ~ arithmics ~ ")"                                          )
        |(   "(" ~ aggregate ~ ")"                                          )
     )
} 

/** Aggregate expressions **/
// Aggregation operation on a value, e.g., "count(x)", "avg(x + y)"
aggregate = { 
    aggregate_op ~ 
    "(" ~ 
    arithmics ~
    ")" 
} 

/** Aggregate operators **/
aggregate_op = { count | sum | min | max }
count = { "count" }
sum = { "sum" }
min = { "min" }
max = { "max" }

/** Comparison expressions **/
// Binary comparison between arithmetic expressions, e.g., "x + y > z + w"
compare_expr = { arithmics ~ compare_op ~ arithmics }

/** Comparison operators **/
compare_op = { 
    equals |
    not_equals | 
    greater_equal_than |
    greater_than |  
    less_equal_than |
    less_than 
}

/** Arithmetic expressions **/
// Simple arithmetic without precedence, e.g., "x + y * z" is parsed left-to-right
arithmics = { factor ~ (arithmic_op ~ factor)* }
factor = { variable | constant }

// Comparison operators
equals = { "=" } 
not_equals = { "!=" }
greater_equal_than = { ">=" }
greater_than = { ">" }
less_equal_than = { "<=" }
less_than = { "<" }

/** Arithmetic operators **/
arithmic_op = { plus | minus | times | divide | modulo }
plus = { "+" }
minus = { "-" }
times = { "*" }
divide = { "/" }
modulo = { "%" }

/** Constants and literals **/
constant = { integer | string } 
// Integer with optional sign
integer = @{ ("+" | "-")? ~ ASCII_DIGIT+ }
// String enclosed in double quotes
string = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Placeholder for unused variables (underscore)
placeholder = { "_" } 

// Identifiers for variables, attributes, and relations
variable = { identifier }
attribute_name = { identifier }
relation_name = { identifier }
// Identifier rules: must start with letter or underscore, can contain letters, numbers, underscores
// non-examples: 1x, x-yz (_x is fine)
identifier = @{ "_"? ~ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "_")* }

// Data types supported in the language
data_type = { int_type | string_type }
int_type = { "number" }
string_type = { "string" }

// Whitespace and comments are ignored during parsing
WHITESPACE = _{ " " | "\t" | NEWLINE }
// Comment starts with # or // and continues until end of line
COMMENT = _{ ("#" | "//") ~ (!NEWLINE ~ ANY)* }
BOOLEAN = { "True" | "False" }