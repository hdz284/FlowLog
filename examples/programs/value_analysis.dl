// ddisasm --asm=./capstone.asm -j 16 --debug-dir /workspace/facts/capstone/ /usr/lib/libcapstone.so.5
// cp /usr/local/src/ddisasm/build/lib/libfunctors.so ./
// souffle -L /usr/local/src/ddisasm/build/lib/ -j 16 -o /workspace/dataset/value_analysis.bin  /workspace/gdlog-multinode/test/souffle/ddisasm/value_analysis.dl
// export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}`pwd`
// DDISASM_DEBUG_DIR=/workspace/facts/capstone/ DDISASM_GTIRB_MODULE_NAME=libcapstone.so.5 /usr/bin/time -v /workspace/ddisasm/extracted.bin -j 16  -F /workspace/facts/capstone/disassembly/ -D /workspace/facts/debug/

.type input_reg <: symbol
.type reg_nullable <: symbol
.type register <: reg_nullable
.type address <: unsigned
.type operand_code <: unsigned
.type operand_index <: unsigned

.type limit_type <: symbol
.type block_type <: symbol

.type access_mode <: symbol
.type symbol_position <: symbol

.type stack_var = [BaseReg:register,StackPos:number]
.type condition_code <: symbol

// need delete
.decl value_reg(EA:address,Reg:register,
                EA_reg1:address,Reg1:reg_nullable,Multiplier:number,Offset:number,Steps:unsigned)
.output value_reg
//
.decl base_relative_jump(EA_relop:address,EA:address)
.output base_relative_jump
.decl base_relative_operand(EA:address,Index:operand_index,Dest:address)
.output base_relative_operand
.decl block_next(Block:address,BlockEnd:address,NextBlock:address)
.output block_next
.decl cmp_defines(EA_jmp:address,EA_dst:address,Reg:register)
.output cmp_defines
.decl compare_and_jump_immediate(EA_cmp:address,EA_jmp:address,CC:condition_code,Reg:register,Immediate:number)
.output compare_and_jump_immediate
.decl compare_and_jump_indirect(EA_cmp:address,EA_jmp:address,CC:condition_code,IndirectOp:operand_code,Immediate:number)
.output compare_and_jump_indirect
.decl compare_and_jump_register(EA_cmp:address,EA_jmp:address,CC:condition_code,Reg1:register,Reg2:register)
.output compare_and_jump_register
.decl const_value_reg_used(UsedEA:address,EADef:address,EARegDef:address,Reg:register,Value:number)
.output const_value_reg_used
.decl def_used_for_address(EA_def:address,Reg:register,Type:symbol)
.output def_used_for_address
.decl flags_and_jump_pair(EA_flags:address,EA_jmp:address,CC:condition_code)
.output flags_and_jump_pair
.decl got_relative_operand(EA:address,Index:operand_index,Dest:address)
.output got_relative_operand
.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address,RegIndex:register)
.output jump_table_element_access
.decl jump_table_signed(TableStart:address,Signed:unsigned)
.output jump_table_signed
.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Scale:number)
.output jump_table_start
.decl jump_table_target(EA:address,Dest:address)
.output jump_table_target
.decl last_value_reg_limit(From:address,To:address,Reg:register,Value:number,LimitType:limit_type,Steps:unsigned)
.output last_value_reg_limit
.decl reg_def_use_def_used(EA_def:address,Var:register,EA_used:address,Index_used:operand_index)
.output reg_def_use_def_used
.decl reg_def_use_live_var_at_block_end(Block:address,BlockUsed:address,Var:register)
.output reg_def_use_live_var_at_block_end
.decl reg_def_use_live_var_at_prior_used(EA_used:address,BlockUsed:address,Var:register)
.output reg_def_use_live_var_at_prior_used
.decl reg_def_use_live_var_used(Block:address,LiveVar:register,UsedVar:register,EA_used:address,Index:operand_index,Moves:unsigned) overridable
.output reg_def_use_live_var_used
.decl reg_def_use_return_val_used(EA_call:address,Callee:address,Reg:register,EA_used:address,Index_used:operand_index)
.output reg_def_use_return_val_used
.decl reg_has_base_image(EA:address,Reg:register)
.output reg_has_base_image
.decl reg_has_got(EA:address,Reg:register)
.output reg_has_got

// .decl reg_arithmetic_operation(EA:address,Dst:register,Src:register,Mult:number,Offset:number)
// .output reg_arithmetic_operation
.decl relative_jump_table_entry_candidate(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)
.input relative_jump_table_entry_candidate




.decl stack_def_use_live_var_used_in_block(Block:address,EA:address,LiveVar:stack_var,UsedVar:stack_var,EA_used:address,Index:operand_index,Moves:unsigned)
.output stack_def_use_live_var_used_in_block
.decl tls_desc_call(Load:address,Call:address,Dest:address)
.output tls_desc_call
.decl tls_get_addr(Load:address,Call:address,Dest:address)
.output tls_get_addr
.decl value_reg_edge(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number)
.output value_reg_edge
.decl value_reg_limit(From:address,To:address,Reg:register,Value:number,LimitType:limit_type)
.output value_reg_limit
.decl value_reg_unsupported(EA:address, Reg:register)
.output value_reg_unsupported

.printsize value_reg
.input base_relative_jump
.input base_relative_operand
.printsize block_next
.printsize cmp_defines
.printsize compare_and_jump_immediate
.printsize compare_and_jump_indirect
.printsize compare_and_jump_register
.printsize const_value_reg_used
.printsize def_used_for_address
.printsize flags_and_jump_pair
.printsize got_relative_operand
.printsize jump_table_element_access
.printsize jump_table_signed
.printsize jump_table_start
.printsize jump_table_target
.printsize last_value_reg_limit
.printsize reg_def_use_def_used
.printsize reg_def_use_live_var_at_block_end
.printsize reg_def_use_live_var_at_prior_used
.printsize reg_def_use_live_var_used
.printsize reg_def_use_return_val_used
.printsize reg_has_base_image
.input reg_has_got
// .printsize reg_arithmetic_operation
.printsize relative_jump_table_entry_candidate


.printsize stack_def_use_live_var_used
.printsize stack_def_use_live_var_used_in_block
.input tls_desc_call
.input tls_get_addr
.printsize value_reg_edge
.printsize value_reg_limit
.printsize value_reg_unsupported

// input from non recursive part
.input block_next
.input compare_and_jump_immediate
.input compare_and_jump_register
.input def_used_for_address
.input got_relative_operand
.input jump_table_element_access
.input reg_def_use_def_used
.input reg_def_use_live_var_used
.input reg_has_base_image
.input relative_jump_table_entry_candidate
.input stack_def_use_def_used
.input stack_def_use_live_var_used_in_block
.input value_reg

// input relations
.decl adjusts_stack_in_block(Block:address,EA:address,BaseReg:register,Offset:number)
.input adjusts_stack_in_block
.decl after_end(EA:address,End:address)
.input after_end
.decl arch_call(EA:address,DestOperandIndex:operand_index)
.input arch_call
.decl arch_cmp_operation(Operation:symbol)
.input arch_cmp_operation
.decl arch_cmp_zero_operation(Operation:symbol)
.input arch_cmp_zero_operation
arch_cmp_zero_operation(""):-
    false.
.decl arch_condition_flags_reg(Reg:register)
.input arch_condition_flags_reg
.decl arch_conditional(EA:address,CC:condition_code)
.input arch_conditional
.decl arch_extend_load(EA:address,Signed:unsigned,SrcBits:unsigned)
.input arch_extend_load
.decl arch_extend_reg(EA:address,Reg:register,Signed:unsigned,SrcBits:unsigned)
.input arch_extend_reg
.decl arch_jump(EA:address)
.input arch_jump
.decl arch_memory_access(AccessType:symbol,EA:address,SrcOp:operand_index,DstOp:operand_index,
    DirectReg:register,BaseReg:reg_nullable,IndexReg:reg_nullable,Mult:number,Offset:number)
.input arch_memory_access
.decl arch_move_reg_imm(EA:address,Dst:register,Imm:number,ImmIndex:operand_index)
.input arch_move_reg_imm
.decl arch_move_reg_reg(EA:address,Dst:register,Src:register)
.input arch_move_reg_reg
.decl arch_pc_relative_addr(EA:address,Reg:register,Target:address)
.input arch_pc_relative_addr
arch_pc_relative_addr(0,"",0):- false.
.decl arch_reg_arithmetic_operation(EA:address,Dst:register,Src:register,Mult:number,Offset:number)
.input arch_reg_arithmetic_operation
.decl arch_reg_reg_arithmetic_operation(EA:address,Dst:register,Src1:register,Src2:register,Mult:number,Offset:number)
.input arch_reg_reg_arithmetic_operation
.decl arch_register_size_bytes(Reg:input_reg,Size:unsigned)
.input arch_register_size_bytes
.decl arch_return_reg(Reg:register)
.input arch_return_reg
.decl arch_stack_pointer(Reg:register)
.input arch_stack_pointer
.decl arch_store_immediate(EA:address,SrcOp:operand_index,DstOp:operand_index,
    Immediate:number,BaseReg:reg_nullable,IndexReg:reg_nullable,Mult:number,Offset:number)
.input arch_store_immediate
arch_store_immediate(0,0,0,0,"NONE","NONE",0,0):- false.
.decl base_address(ea:address)
.input base_address
.decl base_relative_operation(EA_relop:address,EA:address)
.input base_relative_operation
.decl binary_format(Format:symbol)
.input binary_format
.decl block(Block:address)
.input block
.decl block_instruction_next(Block:address,Before:address,After:address)
.input block_instruction_next
.decl block_last_instruction(Block:address,EA:address)
.input block_last_instruction
.decl call_tls_get_addr(Call:address,Reg:register)
.input call_tls_get_addr
.decl cmp_immediate_to_reg(EA:address,Reg:register,Imm_index:operand_index,Immediate:number)
.input cmp_immediate_to_reg
.decl cmp_reg_to_reg(EA:address,Reg1:register,Reg2:register)
.input cmp_reg_to_reg
.decl code_in_block(EA:address,Block:address)
.input code_in_block
.decl conditional_jump(src:address)
.input conditional_jump
.decl data_access(EA:address,Op_index:operand_index,RegSegment:reg_nullable,RegBase:reg_nullable,RegIndex:reg_nullable,Mult:number,Offset:number,Size:unsigned)
.input data_access
.decl data_segment(Begin:address,End:address)
.input data_segment
.decl defined_symbol(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)
.input defined_symbol
.decl direct_call(EA:address,Dest:address)
.input direct_call
.decl direct_jump(src:address, dest:address)
.input direct_jump
.decl got_reference_pointer(EA:address)
.input got_reference_pointer
.decl got_section(name:symbol)
.input got_section
.decl instruction(ea:address,size:unsigned,prefix:symbol,opcode:symbol,
          op1:operand_code,op2:operand_code,op3:operand_code,op4:operand_code,
          immOffset:unsigned,displacementOffset:unsigned)
.input instruction
.decl instruction_displacement_offset(EA:address,Index:operand_index,Offset:unsigned,Size:unsigned)
.input instruction_displacement_offset
.decl instruction_get_dest_op(EA:address,Index:operand_index,Op:operand_code)
.input instruction_get_dest_op
.decl instruction_get_op(ea:address, index:operand_index, operator:operand_code)
.input instruction_get_op
.decl instruction_get_src_op(EA:address,Index:operand_index,Op:operand_code)
.input instruction_get_src_op
.decl instruction_has_relocation(EA:address,Rel:address)
.input instruction_has_relocation
.decl inter_procedural_edge(Src:address,Dest:address)
.input inter_procedural_edge
.decl is_padding(EA:address)
.input is_padding
.decl is_xor_reset(EA:address)
.input is_xor_reset
.decl limit_reg_op(EA:address,DstReg:register,SrcReg:register,Offset:number)
.input limit_reg_op
.decl limit_type_map(CC:condition_code,BranchLT:limit_type,FallthroughLT:limit_type,BranchOffset:number,FallthroughOffset:number)
.input limit_type_map
.decl loaded_section(Beg:address,End:address,Name:symbol)
.input loaded_section
.decl lsda_callsite_addresses(Start:address,End:address,LandingPad:address)
.input lsda_callsite_addresses
.decl may_fallthrough(o:address,d:address)
.input may_fallthrough
.decl next(n:address,m:address)
.input next
.decl no_return_call_propagated(EA:address)
.input no_return_call_propagated
.decl no_value_reg_limit(EA_jmp:address)
.input no_value_reg_limit
.decl op_immediate(Code:operand_code,Offset:number,SizeBytes:unsigned)
.input op_immediate
.decl op_immediate_and_reg(EA:address,Operation:symbol,Reg:register,Imm_index:operand_index,Immediate:number)
.input op_immediate_and_reg
.decl op_indirect(Code:operand_code,Reg1:input_reg,Reg2:input_reg,Reg3:input_reg,
        Multiplier:number,Offset:number,SizeBytes:unsigned)
.input op_indirect
.decl op_indirect_mapped(Op:operand_code,Reg1:reg_nullable,Reg2:reg_nullable,Reg3:reg_nullable,Mult:number,Offset:number,Size:unsigned)
.input op_indirect_mapped
.decl op_regdirect(Code:operand_code,RegisterName:input_reg)
.input op_regdirect
.decl op_regdirect_contains_reg(Op:operand_code,Reg:register)
.input op_regdirect_contains_reg
.decl pc_relative_operand(src:address,index:operand_index, dest:address)
.input pc_relative_operand
.decl possible_rva_operand(EA:address,Index:operand_index,Dest:address)
.input possible_rva_operand
.decl reg_call(Src:address,Reg:register)
.input reg_call
.decl reg_def_use_block_last_def(EA:address,EA_def:address,Var:register)
.input reg_def_use_block_last_def
.decl reg_def_use_def(EA:address,Var:register)
.input reg_def_use_def
.decl reg_def_use_defined_in_block(Block:address,Var:register)
.input reg_def_use_defined_in_block
.decl reg_def_use_flow_def(EA:address,Var:register,EA_next:address,Value:number)
.input reg_def_use_flow_def
.decl reg_def_use_live_var_def(Block:address,VarIdentity:register,LiveVar:register,EA_def:address)
.input reg_def_use_live_var_def
.decl reg_def_use_ref_in_block(Block:address,Var:register)
.input reg_def_use_ref_in_block
.decl reg_def_use_return_block_end(Callee:address,CalleeEnd:address,Block:address,BlockEnd:address)
.input reg_def_use_return_block_end
.decl reg_def_use_used(EA:address,Var:register,Index:operand_index)
.input reg_def_use_used
.decl reg_def_use_used_in_block(Block:address,EA_used:address,Var:register,Index:operand_index)
.input reg_def_use_used_in_block
.decl reg_jump(Src:address,Reg:register)
.input reg_jump
.decl reg_map(RegIn:input_reg,Reg:register)
.input reg_map
.decl reg_used_for(EA:address,Reg:register,Type:symbol)
.input reg_used_for
.decl register_access(EA:address,Register:input_reg,AccessMode:access_mode)
.input register_access
.decl relative_address(EA:address,Size:unsigned,TableStart:address,Reference:address,Dest:address,DestIsFirstOrSecond:symbol)
.input relative_address
.decl relative_address_start(EA:address,Size:unsigned,Reference:address,Dest:address, DestIsFirstOrSecond:symbol)
.input relative_address_start
.decl relocation(EA:address,Type:symbol,Name:symbol,Addend:number,SymbolIndex:unsigned,Section:symbol,RelType:symbol)
.input relocation
.decl relocation_adjustment_total(EA:address,Adjustment:number)
.input relocation_adjustment_total
.decl simple_data_access_pattern(Address:address,Op_index:unsigned,Size:unsigned,FromWhere:address)
.input simple_data_access_pattern
.decl stack_base_reg_move(Block:address,EA:address,Src:register,Dst:register)
.input stack_base_reg_move
.decl stack_def_use_block_last_def(EA:address,EA_def:address,Var:stack_var)
.input stack_def_use_block_last_def
.decl stack_def_use_def(EA:address,Var:stack_var)
.input stack_def_use_def
.decl stack_def_use_defined_in_block(Block:address,Var:stack_var)
.input stack_def_use_defined_in_block
.decl stack_def_use_live_var_def(Block:address,VarIdentity:stack_var,LiveVar:stack_var,EA_def:address)
.input stack_def_use_live_var_def
.decl stack_def_use_moves_limit(Moves:unsigned)
.input stack_def_use_moves_limit
.decl stack_def_use_ref_in_block(Block:address,Var:stack_var)
.input stack_def_use_ref_in_block
.decl stack_def_use_used(EA:address,Var:stack_var,Index:operand_index)
.input stack_def_use_used
.decl stack_def_use_used_in_block(Block:address,EA_used:address,Var:stack_var,Index:operand_index)
.input stack_def_use_used_in_block
.decl step_limit(Limit:unsigned)
.input step_limit
.decl step_limit_small(Limit:unsigned)
step_limit_small(3).
.decl symbol(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)
.input symbol
.decl symbolic_expr_from_relocation(EA:address,Size:unsigned,Symbol:symbol,Offset:number,TargetEA:address)
.input symbolic_expr_from_relocation
.decl take_address(Src:address,Address_taken:address)
.input take_address
.decl tls_descriptor(EA:address,Offset:unsigned)
.input tls_descriptor
.decl tls_index(EA:address,Offset:unsigned)
.input tls_index
.decl tls_segment(Start:address,End:address,Align:unsigned)
.input tls_segment
.decl track_register(Reg:register)
.input track_register

.functor functor_data_valid(EA:address,Size:unsigned):unsigned
.functor functor_data_unsigned(EA:address,Size:unsigned):unsigned
.functor functor_data_signed(EA:address,Size:unsigned):number

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> recursive 

////////////////////////////// block_next
block_next(Block,EA,Dest) :- 
   block_last_instruction(Block,EA),
   jump_table_target(EA,Dest).
////////////////////////////// end of block_next (1/1)

cmp_defines(EA_jmp,EA_dst,Reg) :- 
   compare_and_jump_immediate(_,EA_jmp,"E",Reg,_),
   direct_jump(EA_jmp,EA_dst).

cmp_defines(EA_jmp,EA_dst,Reg) :- 
   compare_and_jump_immediate(_,EA_jmp,"NE",Reg,_),
   may_fallthrough(EA_jmp,EA_dst).

compare_and_jump_immediate(EA_cmp,EA_jmp,CC,Reg,Immediate) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,CC),
   instruction(EA_cmp,_,_,Operation,_,_,_,_,_,_),
   arch_cmp_operation(Operation),
   cmp_immediate_to_reg(EA_cmp,Reg,_,Immediate).

compare_and_jump_indirect(EA_cmp,EA_jmp,CC,IndirectOp,Immediate) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,CC),
   instruction(EA_cmp,_,_,CmpOperation,_,_,_,_,_,_),
   arch_cmp_operation(CmpOperation),
   instruction_get_op(EA_cmp,_,IndirectOp),
   op_indirect(IndirectOp,_,_,_,_,_,_),
   instruction_get_op(EA_cmp,_,ImmOp),
   op_immediate(ImmOp,Immediate,_).

compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,CC),
   cmp_reg_to_reg(EA_cmp,Reg1,Reg2).

const_value_reg_used(UsedEA,EADef,EARegDef,Reg,Value) :- 
   value_reg(EARegDef,Reg,EADef,"NONE",0,Value,_),
   reg_def_use_def_used(EARegDef,Reg,UsedEA,_).


////////////////////////////// def_used_for_address
def_used_for_address(EA_def,Reg,Type) :- 
   reg_def_use_def_used(EA_def,Reg,EA,_),
   reg_used_for(EA,Reg,Type).

def_used_for_address(EA_def,Reg,Type) :- 
   def_used_for_address(EA_used,_,Type),
   reg_def_use_def_used(EA_def,Reg,EA_used,_).

def_used_for_address(EA_def,Reg1,Type) :- 
   def_used_for_address(EALoad,Reg2,Type),
   arch_memory_access("LOAD",EALoad,_,_,Reg2,RegBaseLoad,inlined_IndexReg_113,_,StackPosLoad),
   inlined_IndexReg_113 = "NONE",
   stack_def_use_def_used(EAStore,[RegBaseStore,StackPosStore],EALoad,[RegBaseLoad,StackPosLoad],_),
   arch_memory_access("STORE",EAStore,_,_,Reg1,RegBaseStore,inlined_IndexReg_548,_,StackPosStore),
   inlined_IndexReg_548 = "NONE",
   reg_def_use_def_used(EA_def,Reg1,EAStore,_).
////////////////////////////// end of def_used_for_address (3/3)

flags_and_jump_pair(EA_flags,EA_jmp,CC) :- 
   arch_condition_flags_reg(Reg),
   reg_def_use_def_used(EA_flags,Reg,EA_jmp,_),
   arch_jump(EA_jmp),
   arch_conditional(EA_jmp,CC).

jump_table_element_access(EA,Size,TableStartAddr,"NONE") :- 
   pc_relative_operand(EA,1,TableStartAddr),
   data_access(EA,_,_,_,_,_,_,Size),
   def_used_for_address(EA,_,Type),
   Type = "Jump",
   reg_def_use_def_used(EA,Reg1,EA_add,_),
   reg_def_use_def_used(EA2,Reg2,EA_add,_),
   take_address(EA2,TableStartAddr),
   arch_reg_reg_arithmetic_operation(EA_add,_,Reg2,Reg1,1,0),
   data_segment(Beg,End),
   TableStartAddr >= Beg,
   TableStartAddr <= End.

jump_table_element_access(EA,Size,TableStartAddr,"NONE") :- 
   pc_relative_operand(EA,1,TableStartAddr),
   data_access(EA,_,_,_,_,_,_,Size),
   def_used_for_address(EA,_,Type),
   Type = "Call",
   reg_def_use_def_used(EA,Reg1,EA_add,_),
   reg_def_use_def_used(EA2,Reg2,EA_add,_),
   take_address(EA2,TableStartAddr),
   arch_reg_reg_arithmetic_operation(EA_add,_,Reg2,Reg1,1,0),
   data_segment(Beg,End),
   TableStartAddr >= Beg,
   TableStartAddr <= End.

jump_table_element_access(EA,Size,as(TableStart, address),as(RegBase, register)) :- 
   data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
   RegBase != "NONE",
   RegIndex != "NONE",
   RegIndex_nn = as(RegIndex, register),
   const_value_reg_used(EA,_,_,RegIndex_nn,TableStart),
   data_segment(Beg,End),
   as(TableStart, address) >= Beg,
   as(TableStart, address) <= End.

jump_table_element_access(EA,Size,as(Tmp1, address),as(RegIndex, register)) :-
   data_access(EA,_,"NONE",RegBase,RegIndex, _tmp_70,Offset,Size),
   RegBase != "NONE",
   RegBase_nn = as(RegBase, register),
   RegIndex != "NONE",
   const_value_reg_used(EA,_,_,RegBase_nn,Base),
   data_segment(Beg,End),
   Tmp1 = (Base+Offset),
   as(Tmp1, address) >= Beg,
   as(Tmp1, address) <= End,
   _tmp_70 = as(Size, number).

// TODO: need to escape this rule because we don't have range
// jump_table_max(TableStart,Tmp2) :- 
//    jump_table_element_access(EA,Size,TableStart,RegIndex),
//    code_in_block(EA,Block),
//    !reg_def_use_block_last_def(EA,_,RegIndex),
//    last_value_reg_limit(_,Block,RegIndex,Value,"MAX",_),
//    Value >= 0,
//    Tmp1= (as(Value, unsigned)*Size),
//    Tmp2 = (TableStart+Tmp1).

// jump_table_max(TableStart,) :- 
//    jump_table_element_access(EA,Size,TableStart,RegIndex),
//    code_in_block(EA,_),
//    reg_def_use_block_last_def(EA,EA_def,RegIndex),
//    last_value_reg_limit(EA_def,_,RegIndex,Value,"MAX",_),
//    Value >= 0,
//    Tmp1 = (as(Value, unsigned)*Size),
//    Tmp2 = (TableStart+Tmp1).

// jump_table_max(TableStart2,(TableStart2+(@functor_data_unsigned(generator_0,Size1)*Size2))) :- 
//    jump_table_element_access(EA1,Size1,TableStart1,_),
//    jump_table_max(TableStart1,TableEnd1),
//    reg_def_use_def_used(EA1,Reg,EA2,_),
//    EA1 != EA2,
//    jump_table_element_access(EA2,Size2,TableStart2,Reg),
//    TableStart1 != TableStart2,
//    @functor_data_valid(generator_0,Size1) = 1,
//    generator_0 = range(TableStart1,(TableEnd1+Size1),Size1).

jump_table_signed(TableStart,Signed) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   arch_extend_load(EA,Signed, _tmp_71),
    _tmp_71 = (8*Size).

jump_table_signed(TableStart,Signed) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_used,_,EA,Reg,_,_,_),
   arch_extend_reg(EA_used,Reg,Signed, _tmp_72),
    _tmp_72 = (8*Size).

jump_table_signed(TableStart,0) :- 
   jump_table_element_access(EA,_,TableStart,_),
   instruction_get_dest_op(EA,_,DstOp),
   op_regdirect(DstOp,DefReg),
   reg_map(DefReg,DefRegMapped),
   value_reg(EA_used,_,EA,DefRegMapped,_,_,_),
   instruction_get_src_op(EA_used,_,Op),
   op_regdirect(Op,UsedReg),
   reg_map(UsedReg,DefRegMapped),
   arch_register_size_bytes(DefReg,DefSize),
   arch_register_size_bytes(UsedReg,UsedSize),
   UsedSize > DefSize.

jump_table_signed(TableStart,1) :- 
   jump_table_element_access(_,PtrSize,TableStart,_),
   PtrSize = 8.

// jump_table_start(EA_jump,4,(ImageBase+Value),ImageBase,1) :- 
//    base_address(ImageBase),
//    base_relative_jump(EA_base,EA_jump),
//    base_relative_operand(EA_base,_,Value).

jump_table_start(EA_jump,Size,TableStart,as(Base, address),Scale) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
   Reg != "NONE",
   reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
   reg_call(EA_jump,_),
   code_in_block(EA_jump,_).

// jump_table_start(EA_jump,Size,TableStart,as(Base, address),Scale) :- 
//    jump_table_element_access(EA,Size,TableStart,_),
//    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
//    Reg != "NONE",
//    reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
//    reg_call(EA_jump,_),
//    code_in_block(EA_jump,_).

jump_table_start(EA_jump,Size,TableStart,as(Base, address),Scale) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
   Reg != "NONE",
   reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_).

jump_table_start(EA_jump,Size,as(TableReference, address),as(TableReference, address),1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_591,_,_,_,_,_,_),
   inlined_Operation_591 = "ADD",
   jump_table_element_access(EA_base,Size, _tmp_73,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
    _tmp_73 = as(TableReference, address).

jump_table_start(EA_jump,Size,as(TableReference, address),as(TableReference, address),-1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_593,_,_,_,_,_,_),
   inlined_Operation_593 = "SUB",
   jump_table_element_access(EA_base,Size, _tmp_74,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
    _tmp_74 = as(TableReference, address).

jump_table_start(EA_jump,Size,TableStart,as(TableReference, address),1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_590,_,_,_,_,_,_),
   inlined_Operation_590 = "ADD",
   jump_table_element_access(EA_base,Size,TableStart,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
   code_in_block( _tmp_153,_),
    _tmp_153 = as(TableReference, address).

jump_table_start(EA_jump,Size,TableStart,as(TableReference, address),-1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_592,_,_,_,_,_,_),
   inlined_Operation_592 = "SUB",
   jump_table_element_access(EA_base,Size,TableStart,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
   code_in_block( _tmp_154,_),
    _tmp_154 = as(TableReference, address).

////////////////////////////// jump_table_target
jump_table_target(EA,Dest) :- 
   jump_table_start(EA,Size,TableStart,_,_),
   relative_jump_table_entry_candidate(_,TableStart,Size,_,Dest,_,_).
////////////////////////////// end of jump_table_target (1/1)

last_value_reg_limit(From,To,Reg,Value,LimitType,0) :- 
   value_reg_limit(From,To,Reg,Value,LimitType).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   !conditional_jump(BlockEnd),
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   no_value_reg_limit(BlockEnd),
   Tmp1 = (Steps + 1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType, Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   cmp_defines(BlockEnd,BlockNext,Reg),
   Reg != PropagatedReg,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   cmp_defines(BlockEnd,BlockNext,Reg),
   Reg != PropagatedReg,
   Tmp1 = (Steps + 1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   cmp_defines(BlockEnd,DefinedNext,PropagatedReg),
   BlockNext != DefinedNext,
   Tmp1 = (Steps + 1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   value_reg_limit(BlockEnd,BlockNext,Reg,_,_),
   Reg != PropagatedReg,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   value_reg_limit(BlockEnd,BlockNext,PropagatedReg,Val,Type),
   PropagatedType = "MAX",
   Type = "MAX",
   PropagatedVal < Val,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   value_reg_limit(BlockEnd,BlockNext,PropagatedReg,Val,Type),
   PropagatedType = "MIN",
   Type = "MIN",
   PropagatedVal > Val,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(BlockEnd,DstReg,SrcReg,Offset),
   EA <= BlockEnd,
   BlockEnd <= BlockEnd,
   code_in_block(BlockEnd,Block),
   block_next(Block,BlockEnd,EA_next),
   !reg_def_use_block_last_def(BlockEnd,_,SrcReg),
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(From,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(BlockEnd,DstReg,SrcReg,Offset),
   EA <= BlockEnd,
   BlockEnd <= BlockEnd,
   code_in_block(BlockEnd,Block),
   block_next(Block,BlockEnd,EA_next),
   reg_def_use_block_last_def(BlockEnd,From,SrcReg),
   Tmp1 = (Steps+1).

last_value_reg_limit(EA_mov,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType, Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(From,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(EA_mov,DstReg,SrcReg,Offset),
   EA <= EA_mov,
   EA_mov <= BlockEnd,
   code_in_block(EA_mov,Block),
   EA_mov != BlockEnd,
   code_in_block(EA_mov,inlined_Block_193),
   may_fallthrough(EA_mov,EA_next),
   code_in_block(EA_next,inlined_Block_193),
   reg_def_use_block_last_def(EA_mov,From,SrcReg),
   Tmp1 = (Steps+1).

last_value_reg_limit(EA_mov,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
   step_limit_small(StepLimit),
   last_value_reg_limit(_,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= StepLimit,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(EA_mov,DstReg,SrcReg,Offset),
   EA <= EA_mov,
   EA_mov <= BlockEnd,
   code_in_block(EA_mov,Block),
   EA_mov != BlockEnd,
   code_in_block(EA_mov,inlined_Block_194),
   may_fallthrough(EA_mov,EA_next),
   code_in_block(EA_next,inlined_Block_194),
   !reg_def_use_block_last_def(EA_mov,_,SrcReg),
   Tmp1 = (Steps+1).

no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "O".
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "NO".
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "P".
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "PE".
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "S".
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "NS".

no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   !reg_def_use_block_last_def(EA_cmp,_,Reg1),
   !reg_def_use_block_last_def(EA_cmp,_,Reg2).

no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   reg_def_use_block_last_def(EA_cmp,EA,Reg1),
   !arch_move_reg_imm(EA,Reg1,_,_),
   !reg_def_use_block_last_def(EA_cmp,_,Reg2).

no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   reg_def_use_block_last_def(EA_cmp,EA,Reg2),
   !arch_move_reg_imm(EA,Reg2,_,_),
   !reg_def_use_block_last_def(EA_cmp,_,Reg1).

no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   reg_def_use_block_last_def(EA_cmp,EA,Reg1),
   !arch_move_reg_imm(EA,Reg1,_,_),
   reg_def_use_block_last_def(EA_cmp,_,Reg2),
   !arch_move_reg_imm(EA,Reg2,_,_).

no_value_reg_limit(EA_jmp) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,_),
   instruction(EA_cmp,_,_,Operation,_,_,_,_,_,_),
   !arch_cmp_operation(Operation).

////////////////////////////////// reg_def_use_def_used
reg_def_use_def_used(EA_def,Var,EA_used,Index) :-
   reg_def_use_used(EA_used,Var,Index),
   reg_def_use_block_last_def(EA_used,EA_def,Var).

reg_def_use_def_used(EA_def,VarIdentity,EA_used,Index) :- 
   reg_def_use_live_var_at_block_end(Block,BlockUsed,Var),
   reg_def_use_live_var_def(Block,VarIdentity,Var,EA_def),
   reg_def_use_live_var_used(BlockUsed,Var,Var,EA_used,Index,_).  
.plan 1:(3,1,2)

reg_def_use_def_used(EA_def,Var,Next_EA_used,NextIndex) :- 
   reg_def_use_live_var_at_prior_used(EA_used,NextUsedBlock,Var),
   reg_def_use_def_used(EA_def,Var,EA_used,_),
   reg_def_use_live_var_used(NextUsedBlock,Var,Var,Next_EA_used,NextIndex,_).

reg_def_use_def_used(EA_def,Reg,EA_used,Index) :- 
   reg_def_use_return_val_used(_,Callee,Reg,EA_used,Index),
   reg_def_use_return_block_end(Callee,_,_,BlockEnd),
   reg_def_use_block_last_def(BlockEnd,EA_def,Reg).
////////////////////////////////// end of reg_def_use_def_used (4/4)

////////////////////////////////// reg_def_use_live_var_at_block_end
reg_def_use_live_var_at_block_end(PrevBlock,Block,Var) :- 
   block_next(PrevBlock,PrevBlockEnd,Block),
   reg_def_use_live_var_used(Block,Var,_,_,_,_),
   !reg_def_use_flow_def(PrevBlockEnd,Var,Block,_).

reg_def_use_live_var_at_block_end(PrevBlock,BlockUsed,Var) :- 
   reg_def_use_live_var_at_block_end(Block,BlockUsed,Var),
   !reg_def_use_ref_in_block(Block,Var),
   block_next(PrevBlock,_,Block). 
.plan 1:(2,1)
////////////////////////////////// end of reg_def_use_live_var_at_block_end (2/2)

////////////////////////////////// reg_def_use_live_var_at_prior_used
reg_def_use_live_var_at_prior_used(EA_used,BlockUsed,Var) :- 
   reg_def_use_live_var_at_block_end(Block,BlockUsed,Var),
   reg_def_use_used_in_block(Block,EA_used,Var,_),
   !reg_def_use_defined_in_block(Block,Var).
////////////////////////////////// end of reg_def_use_live_var_at_prior_used (1/1)



////////////////////////////////// reg_def_use_live_var_def
reg_def_use_live_var_used(RetBlock,Reg,Reg,EA_used,Index,1) :- 
   reg_def_use_return_block_end(Callee,_,RetBlock,RetBlockEnd),
   !reg_def_use_block_last_def(RetBlockEnd,_,Reg),
   reg_def_use_return_val_used(_,Callee,Reg,EA_used,Index).
////////////////////////////////// end of reg_def_use_live_var_def (1/1)



////////////////////////////////// reg_def_use_return_val_used
reg_def_use_return_val_used(EA_call,Callee,Reg,EA_used,Index_used) :- 
   arch_return_reg(Reg),
   reg_def_use_def_used(EA_call,Reg,EA_used,Index_used),
   direct_call(EA_call,Callee).
////////////////////////////////// end of reg_def_use_return_val_used (1/1)

reg_has_base_image(EA,Reg) :- 
   reg_has_base_image(EA2,Reg2),
   reg_def_use_def_used(EA2,Reg2,EA,_),
   arch_move_reg_reg(EA,Reg,Reg2).

reg_has_base_image(EA,Reg) :- 
   reg_has_base_image(EA2,Reg2),
   reg_def_use_def_used(EA2,Reg2,EA,_),
   arch_reg_reg_arithmetic_operation(EA,Reg,Reg2,_,Mult,0),
   Mult > 1.

////////////////////////////////// reg_reg_arithmetic_operation_defs
.decl reg_reg_arithmetic_operation_defs(EA:address,Reg_def:register,EA_def1:address,Reg1:register,EA_def2:address,Reg2:register,Mult:number,Offset:number)
.output reg_reg_arithmetic_operation_defs
.printsize reg_reg_arithmetic_operation_defs
reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset) :- 
   def_used_for_address(EA,Reg_def,_),
   arch_reg_reg_arithmetic_operation(EA,Reg_def,Reg1,Reg2,Mult,Offset),
   Reg1 != Reg2,
   reg_def_use_def_used(EA_def1,Reg1,EA,_),
   EA != EA_def1,
   reg_def_use_def_used(EA_def2,Reg2,EA,_),
   EA != EA_def2.
.plan 1:(3,1,2,4), 2:(4,1,2,3)
////////////////////////////////// end of reg_reg_arithmetic_operation_defs (1/1)

////////////////////////////////// stack_def_use_def_used 
.decl stack_def_use_def_used(EA_def:address,VarDef:stack_var,EA_used:address,VarUsed:stack_var,Index_used:operand_index)
.output stack_def_use_def_used
.printsize stack_def_use_def_used

stack_def_use_def_used(EA_def,VarDef,EA_used,VarUsed,Index) :- 
   stack_def_use_live_var_at_block_end(Block,BlockUsed,Var),
   stack_def_use_live_var_def(Block,VarDef,Var,EA_def),
   stack_def_use_live_var_used(BlockUsed,Var,VarUsed,EA_used,Index,_).
.plan 1:(3,1,2)

stack_def_use_def_used(EA_def,DefVar,EA_used,UsedVar,Index) :- 
   stack_def_use_live_var_used_in_block(_,EA,DefVar,UsedVar,EA_used,Index,_),
   may_fallthrough(EA_def,EA),
   code_in_block(EA_def,Block),
   code_in_block(EA,Block),
   stack_def_use_def(EA_def,DefVar).
 
stack_def_use_def_used(EA_def,VarDef,Next_EA_used,VarUsed,NextIndex) :- 
   stack_def_use_live_var_at_prior_used(EA_used,NextUsedBlock,Var),
   stack_def_use_def_used(EA_def,VarDef,EA_used,Var,_),
   stack_def_use_live_var_used(NextUsedBlock,Var,VarUsed,Next_EA_used,NextIndex,_).
////////////////////////////////// end of stack_def_use_def_used (3/3)


////////////////////////////////// stack_def_use_live_var_at_block_end
.decl stack_def_use_live_var_at_block_end(Block:address,BlockUsed:address,Var:stack_var)
.output stack_def_use_live_var_at_block_end
.printsize stack_def_use_live_var_at_block_end

stack_def_use_live_var_at_block_end(PrevBlock,BlockUsed,[inlined_BaseReg_374,inlined_StackPos_374]) :- 
   stack_def_use_live_var_at_block_end(Block,BlockUsed,[inlined_BaseReg_374,inlined_StackPos_374]),
   !stack_def_use_ref_in_block(Block,[inlined_BaseReg_374,inlined_StackPos_374]),
   !reg_def_use_defined_in_block(Block,inlined_BaseReg_374),
   block_next(PrevBlock,_,Block).
.plan 1:(2,1)

stack_def_use_live_var_at_block_end(PrevBlock,Block,Var) :- 
   block_next(PrevBlock,_,Block),
   stack_def_use_live_var_used(Block,Var,_,_,_,_).
////////////////////////////////// end of stack_def_use_live_var_at_block_end (2/2)


////////////////////////////////// stack_def_use_live_var_at_prior_used
.decl stack_def_use_live_var_at_prior_used(EA_used:address,BlockUsed:address,Var:stack_var)
.output stack_def_use_live_var_at_prior_used
.printsize stack_def_use_live_var_at_prior_used
stack_def_use_live_var_at_prior_used(EA_used,BlockUsed,[inlined_BaseReg_375,inlined_StackPos_375]) :- 
   stack_def_use_live_var_at_block_end(Block,BlockUsed,[inlined_BaseReg_375,inlined_StackPos_375]),
   stack_def_use_used_in_block(Block,EA_used,[inlined_BaseReg_375,inlined_StackPos_375],_),
   !reg_def_use_defined_in_block(Block,inlined_BaseReg_375),
   !stack_def_use_defined_in_block(Block,[inlined_BaseReg_375,inlined_StackPos_375]).
////////////////////////////////// end of stack_def_use_live_var_at_prior_used (1/1)


////////////////////////////////// stack_def_use_live_var_def
.decl stack_def_use_live_var_used(Block:address,LiveVar:stack_var,UsedVar:stack_var,EA_used:address,Index:operand_index,Moves:unsigned) overridable
.output stack_def_use_live_var_used
.printsize stack_def_use_live_var_used
stack_def_use_live_var_used(Block,LiveVar,UsedVar,EA_used,Index,Moves) :- 
   stack_def_use_live_var_used_in_block(Block,Block,LiveVar,UsedVar,EA_used,Index,Moves).
////////////////////////////////// end of stack_def_use_live_var_def (1/1)


stack_def_use_live_var_used_in_block(Block,NextEA,[BaseReg,StackPos],VarUsed,EA_used,Index,(Moves+1)) :- 
   adjusts_stack_in_block(Block,_,BaseReg,_),
   stack_def_use_live_var_at_block_end(Block,BlockUsed,[BaseReg,StackPos]),
   stack_def_use_live_var_used(BlockUsed,[BaseReg,StackPos],VarUsed,EA_used,Index,Moves),
   stack_def_use_moves_limit(MovesLimit),
   Moves <= MovesLimit,
   block_last_instruction(Block,LastEA),
   next(LastEA,NextEA).

stack_def_use_live_var_used_in_block(Block,NextEA,[BaseReg,StackPos],VarUsed,EA_used,Index,(Moves+1)) :- 
   stack_base_reg_move(Block,_,_,BaseReg),
   stack_def_use_live_var_at_block_end(Block,BlockUsed,[BaseReg,StackPos]),
   stack_def_use_live_var_used(BlockUsed,[BaseReg,StackPos],VarUsed,EA_used,Index,Moves),
   stack_def_use_moves_limit(MovesLimit),
   Moves <= MovesLimit,
   block_last_instruction(Block,LastEA),
   next(LastEA,NextEA).

stack_def_use_live_var_used_in_block(Block,EA,[BaseReg,StackPos],[FinalBaseReg,FinalStackPos],EA_used,Index,Moves) :- 
   stack_def_use_live_var_used_in_block(Block,Next,[BaseReg,StackPos],[FinalBaseReg,FinalStackPos],EA_used,Index,Moves),
   block_instruction_next(Block,EA,Next),
   !reg_def_use_def(EA,BaseReg),
   !stack_def_use_def(EA,[BaseReg,StackPos]).

stack_def_use_live_var_used_in_block(Block,EA,[BaseReg,Tmp1],UsedVar,EA_used,Index,Moves) :- 
   stack_def_use_live_var_used_in_block(Block,Next,[BaseReg,StackPos],UsedVar,EA_used,Index,Moves),
   block_instruction_next(Block,EA,Next),
   adjusts_stack_in_block(_,EA,BaseReg,Offset),
   !stack_def_use_def(EA,[BaseReg,StackPos]),
   arch_stack_pointer(BaseReg),
   Tmp1 = (StackPos+Offset)
   Tmp1 >= 0.

stack_def_use_live_var_used_in_block(Block,EA,[BaseReg,Tmp1],UsedVar,EA_used,Index,Moves) :- 
   stack_def_use_live_var_used_in_block(Block,Next,[BaseReg,StackPos],UsedVar,EA_used,Index,Moves),
   block_instruction_next(Block,EA,Next),
   adjusts_stack_in_block(_,EA,BaseReg,Offset),
   !stack_def_use_def(EA,[BaseReg,StackPos]),
   !arch_stack_pointer(BaseReg),
   Tmp1 = (StackPos+Offset).

stack_def_use_live_var_used_in_block(Block,EA,[SrcBaseReg,StackPos],UsedVar,EA_used,Index,Moves) :- 
   stack_def_use_live_var_used_in_block(Block,Next,[DstBaseReg,StackPos],UsedVar,EA_used,Index,Moves),
   block_instruction_next(Block,EA,Next),
   stack_base_reg_move(_,EA,SrcBaseReg,DstBaseReg).

value_reg(EA,Reg,EA,"NONE",0,Immediate,1) :- 
   def_used_for_address(EA,Reg,_),
   arch_move_reg_imm(EA,Reg,Immediate,_),
   !instruction_has_relocation(EA,_).

value_reg(EA,Reg,EA,"NONE",0,0,1) :- 
   def_used_for_address(EA,Reg,_),
   is_xor_reset(EA).

value_reg(EA,Reg,EA,"NONE",0,Immediate,1) :- 
   def_used_for_address(EA,Reg,_),
   reg_def_use_flow_def(EA,Reg,_,Immediate).

value_reg(EA,Reg,EA,Reg,1,0,1) :- 
   def_used_for_address(EA,Reg,_),
   value_reg_unsupported(EA,Reg).

value_reg(EA,Reg,EA,Reg,1,0,1) :- 
   def_used_for_address(EA,Reg,_),
   value_reg_unsupported(EA,Reg).

value_reg(EA,Reg,EA_from,"Unknown",Immediate,Base,Tmp2) :- 
   step_limit(StepLimit),
   value_reg(EA,Reg,EA_from,"NONE",0,Base,Steps),
   Tmp1 = (StepLimit-2)
   Steps <= Tmp1,
   value_reg_edge(EA,Reg,EA,Reg,1,Immediate),
   Immediate != 0,
   Tmp2 = (Steps+1).

value_reg(EA1,Reg1,EA3,Reg3,Tmp2,Tmp4,Tmp5) :- 
   step_limit(StepLimit),
   value_reg(EA2,Reg2,EA3,Reg3,Multiplier2,Offset2,Steps),
   Tmp1 = (StepLimit-2)
   Steps <= Tmp1,
   value_reg_edge(EA1,Reg1,EA2,Reg2,Multiplier,Offset),
   EA1 > EA2,
   Tmp2 = (Multiplier*Multiplier2),
   Tmp3 = (Offset2*Multiplier),
   Tmp4 = (Tmp3+Offset),
   Tmp5 = (Steps+1).

value_reg(EA1,Reg1,EA3,Reg3,Tmp1,Tmp3,Tmp4) :- 
   step_limit(StepLimit),
   value_reg(EA2,Reg2,EA3,Reg3,Multiplier2,Offset2,Steps),
   Steps <= (StepLimit-6),
   value_reg_edge(EA1,Reg1,EA2,Reg2,Multiplier,Offset),
   EA1 < EA2,
   Tmp1 = (Multiplier*Multiplier2),
   Tmp2 = (Offset2*Multiplier),
   Tmp3 = (Tmp2+Offset),
   Tmp4 = (Steps+5).

value_reg(EA,Reg,EA,"NONE",0,as(Address, number),1) :- 
   def_used_for_address(EA,Reg,_),
   instruction_has_relocation(EA,EA_rel),
   symbolic_expr_from_relocation(EA_rel,_,_,_,Address).

value_reg(EA,Reg,EA,"NONE",0,as(Offset, number),1) :- 
   binary_format("ELF"),
   got_relative_operand(EA,1,Offset),
   instruction(EA,_,_,"LEA",_,Op2,0,0,_,_),
   op_regdirect_contains_reg(Op2,Reg),
   track_register(Reg).

value_reg(EA,Reg_def,EA_third,Reg3,Tmp3,Tmp6,Tmp8) :- 
   step_limit(StepLimit),
   reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset),
   value_reg(EA_def1,Reg1,EA_third,Reg3,Mult1,Offset1,Steps1),
   Tmp1 = (StepLimit-3),
   Steps1 <= Tmp1,
   EA != EA_third,
   value_reg(EA_def2,Reg2,EA_third,Reg3,Mult2,Offset2,Steps2),
   Steps2 <= Tmp1,
   Tmp2 = (Mult*Mult2),
   Tmp3 = (Mult1+Tmp2),
   Tmp4 = (Offset+Offset1),
   Tmp5 = (Offset2*Mult),
   Tmp6 = (Tmp4+Tmp5),
   Tmp7 = max(Steps1,Steps2),
   Tmp8 = (Tmp7+2).

value_reg(EA,Reg_def,EA_third,Reg3,Tmp2,Tmp5,Tmp7) :- 
   step_limit(StepLimit),
   reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset),
   value_reg(EA_def1,Reg1,_,"NONE",_,Offset1,Steps1),
   Tmp1 = (StepLimit-3),
   Steps1 <= Tmp1,
   value_reg(EA_def2,Reg2,EA_third,Reg3,Mult2,Offset2,Steps2),
   Steps2 <= Tmp1,
   EA != EA_third,
   Reg3 != "NONE",
   Tmp2 = (Mult*Mult2),
   Tmp3 =(Offset+Offset1),
   Tmp4 = (Offset2*Mult),
   Tmp5 = (Tmp3+Tmp4),
   Tmp6 = max(Steps1,Steps2),
   Tmp7 = (Tmp6+2).

value_reg(EA,Reg_def,EA_third,Reg3,Mult1,Tmp4,Tmp6) :- 
   step_limit(StepLimit),
   reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset),
   value_reg(EA_def2,Reg2,_,"NONE",_,Offset2,Steps2),
   Tmp1 = (StepLimit-3),
   Steps2 <= Tmp1,
   value_reg(EA_def1,Reg1,EA_third,Reg3,Mult1,Offset1,Steps1),
   Steps1 <= Tmp1,
   Reg3 != "NONE",
   EA != EA_third,
   Tmp2 = (Offset+Offset1),
   Tmp3 = (Offset2*Mult),
   Tmp4 = (Tmp2+Tmp3),
   Tmp5 = max(Steps1,Steps2),
   Tmp6 = (Tmp5+2).

value_reg(EALoad,Reg2,EALoad,"NONE",0,Immediate,1) :- 
   arch_store_immediate(EAStore,_,_,Immediate,RegBaseStore,"NONE",_,StackPosStore),
   stack_def_use_def_used(EAStore,[RegBaseStore,StackPosStore],EALoad,[RegBaseLoad,StackPosLoad],_),
   arch_memory_access("LOAD",EALoad,_,_,Reg2,RegBaseLoad,inlined_IndexReg_452,_,StackPosLoad),
   inlined_IndexReg_452 = "NONE",
   def_used_for_address(EALoad,Reg2,_).

value_reg(EA,Reg,EA,"NONE",0,as(TargetAddr, number),1) :- 
   def_used_for_address(EA,Reg,_),
   arch_memory_access("LOAD",EA,SrcOp,_,Reg,_,_,_,_),
   simple_data_access_pattern(MemAddr,SrcOp,Size,EA),
   4 <= Size,
   Size <= 8,
   symbolic_expr_from_relocation(MemAddr,Size,Symbol,_,TargetAddr),
   defined_symbol(_,_,_,_,_,_,_,_,Symbol),
   as(TargetAddr, number) >= 0.

/////////////////////////////////////////////
.decl value_reg_functor(EA:address,Reg:register,
                EA_reg1:address,Reg1:reg_nullable,Multiplier:number,Offset:number,Steps:unsigned)
.ouput value_reg_functor
value_reg_functor(EA,Reg,EA,"NONE",0,@functor_data_signed(MemAddr,Size),1) :- 
   def_used_for_address(EA,Reg,_),
   arch_memory_access("LOAD",EA,SrcOp,_,Reg,_,_,_,_),
   simple_data_access_pattern(MemAddr,SrcOp,Size,EA),
   4 <= Size,
   Size <= 8,
   @functor_data_valid(MemAddr,Size) = 1,
   !symbolic_expr_from_relocation(MemAddr,_,_,_,_),
   @functor_data_signed(MemAddr,Size) >= 0.
/////////////////////////////////////////////

value_reg_edge(EA,Reg,EA_prev,Reg_origin,1,0) :- 
   def_used_for_address(EA_prev,Reg_origin,_),
   reg_def_use_def_used(EA_prev,Reg_origin,EA,_),
   arch_move_reg_reg(EA,Reg,Reg_origin),
   track_register(Reg),
   EA != EA_prev.

value_reg_edge(EA,Dst,EA_prev,Src,Mult,Immediate) :- 
   def_used_for_address(EA_prev,Src,_),
   reg_def_use_def_used(EA_prev,Src,EA,_),
   arch_reg_arithmetic_operation(EA,Dst,Src,Mult,Immediate),
   track_register(Dst).

value_reg_edge(EALoad,Reg2,EAPrev,Reg1,1,0) :- 
   stack_def_use_def_used(EAStore,[RegBaseStore,StackPosStore],EALoad,[RegBaseLoad,StackPosLoad],_),
   arch_memory_access("STORE",EAStore,_,_,Reg1,RegBaseStore,inlined_IndexReg_472,_,StackPosStore),
   inlined_IndexReg_472 = "NONE",
   arch_memory_access("LOAD",EALoad,_,_,Reg2,RegBaseLoad,inlined_IndexReg_886,_,StackPosLoad),
   inlined_IndexReg_886 = "NONE",
   reg_def_use_def_used(EAPrev,Reg1,EAStore,_).

value_reg_limit(EA_jmp,EA_branch,Reg,Tmp1,BranchLT) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,Reg,Immediate),
   track_register(Reg),
   limit_type_map(CC,BranchLT,_,BranchOffset,_),
   direct_jump(EA_jmp,EA_branch),
   may_fallthrough(EA_jmp,_),
   Tmp1 = (Immediate+BranchOffset).

value_reg_limit(EA_jmp,EA_fallthrough,Reg,Tmp1,FallthroughLT) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,Reg,Immediate),
   track_register(Reg),
   limit_type_map(CC,_,FallthroughLT,_,FallthroughOffset),
   direct_jump(EA_jmp,_),
   may_fallthrough(EA_jmp,EA_fallthrough),
   Tmp1 = (Immediate+FallthroughOffset).

value_reg_limit(EA_jmp,EA_branch,Reg2,Tmp1,LT1) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,LT1,_,Offset1,_),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg1),
   arch_move_reg_imm(EA_regdef,Reg1,Immediate,_),
   track_register(Reg2),
   direct_jump(EA_jmp,EA_branch),
   may_fallthrough(EA_jmp,_),
   Tmp1 = (Immediate+Offset1).

value_reg_limit(EA_jmp,EA_branch,Reg1,Tmp1,LT2) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,_,LT2,_,Offset2),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg2),
   arch_move_reg_imm(EA_regdef,Reg2,Immediate,_),
   track_register(Reg1),
   direct_jump(EA_jmp,EA_branch),
   may_fallthrough(EA_jmp,_),
   Tmp1 = (Immediate+Offset2).

value_reg_limit(EA_jmp,EA_fallthrough,Reg2,Tmp1,LT2) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,_,LT2,_,Offset2),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg1),
   arch_move_reg_imm(EA_regdef,Reg1,Immediate,_),
   track_register(Reg2),
   direct_jump(EA_jmp,_),
   may_fallthrough(EA_jmp,EA_fallthrough),
   Tmp1 = (Immediate+Offset2).

value_reg_limit(EA_jmp,EA_fallthrough,Reg1,Tmp1,LT1) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,LT1,_,Offset1,_),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg2),
   arch_move_reg_imm(EA_regdef,Reg2,Immediate,_),
   track_register(Reg1),
   direct_jump(EA_jmp,_),
   may_fallthrough(EA_jmp,EA_fallthrough),
   Tmp1 = (Immediate+Offset1).

value_reg_limit(EA_target,EA_limited,Reg,Tmp1,BranchLT) :- 
   compare_and_jump_indirect(EA_cmp,EA_jmp,CC,IndirectOp,Immediate),
   limit_type_map(CC,BranchLT,_,BranchOffset,_),
   next(EA_cmp,EA_jmp),
   direct_jump(EA_jmp,EA_target),
   arch_memory_access("LOAD",EA_target,_,_,Reg,_,_,_,_),
   track_register(Reg),
   instruction_get_op(EA_target,_,IndirectOp),
   code_in_block(EA_target,inlined_Block_887),
   may_fallthrough(EA_target,EA_limited),
   code_in_block(EA_limited,inlined_Block_887),
   Tmp1 = (Immediate+BranchOffset).

value_reg_limit(EA_target,EA_limited,Reg,Tmp1,FallthroughLT) :- 
   compare_and_jump_indirect(EA_cmp,EA_jmp,CC,IndirectOp,Immediate),
   limit_type_map(CC,_,FallthroughLT,_,FallthroughOffset),
   next(EA_cmp,EA_jmp),
   may_fallthrough(EA_jmp,EA_target),
   arch_memory_access("LOAD",EA_target,_,_,Reg,_,_,_,_),
   track_register(Reg),
   instruction_get_op(EA_target,_,IndirectOp),
   code_in_block(EA_target,inlined_Block_888),
   may_fallthrough(EA_target,EA_limited),
   code_in_block(EA_limited,inlined_Block_888),
   Tmp1 = (Immediate+FallthroughOffset).

value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_move_reg_reg(EA,Dst,Src),
   track_register(Dst),
   !track_register(Src).
value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_call(EA,_).
value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_memory_access("LOAD",EA,_,_,Reg,RegBase,_,_,_),
   RegBase != "NONE".
value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_memory_access("LOAD",EA,_,_,Reg,_,RegIndex,_,_),
   RegIndex != "NONE".

